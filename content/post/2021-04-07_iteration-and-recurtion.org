---
title: "迭代与递归"
date: 2021-04-07T16:03:50+08:00
draft: false
tags: ['sicp']
categories: ['learning']
---
* 递归处理与递归过程
  用一个经典的递归例子：阶乘 来说明。
  #+begin_src scheme
    (define (factorial n)
      (if (= n 1)
          1
          (* n factorial (- n 1))))
  #+end_src
  以上是经典的阶乘的递归处理，若输入为1则输出1,否则结果为当前n×递归执行n-1.
  #+begin_src scheme
    (define (factorial n)
      (fact-iter 1 1 n))
    (define (fact-iter product counter max-count)
      (if (> counter max-count)
          product
          (fact-iter (* counter product)
                     (+ count 1)
                     max-count)))
   #+end_src
   以上是阶乘的迭代处理。我们在每一次迭代（循环）中输入了得到下一结果所需的所有信息，编译器无需像在递归处理中一样
   保存每次n的值以计算最后的结果。

   但是用我们熟悉的c语言来理解以上这段代码，我们会觉得在形式上 =fact-iter= 函数在函数体中调用了自身，也应该算作
   递归而不是迭代。在c语言中，我们理解的迭代是使用 =for= 或 =while= 在代码块中显式地更改变量，以上代码很明显
   没有使用“循环”。这就引出了递归过程与递归处理的区别。以上代码使用的确实是我们在c语言中称作“递归过程”的代码形式，
   但根据我们对“迭代处理”的定义，即编译器无需保存中间变量，它很显然是符合“迭代处理”要求的。在c语言和其他很多
   语言中，使用递归过程的迭代处理会和普通的递归处理一样，在每次递归中保存一些值，导致无法到达很深的递归深度。在lisp
   编译器的实现中使用了“尾递归”优化技术，即若一个函数在调用自身时（满足递归过程条件）将该调用放在最后执行，并且
   无需保存多余的变量，将所有必要的变量输入下一层，那么编译器在执行的时候就不会保存多余的信息，而是像迭代那样直接
   用下一层来覆盖当前层。
  
* 多种形式的递归与迭代
** 线性递归
   上面factorial的递归实现中每次进入一个下一层，保存的数据随n的增大是线性增长的。这种形式的递归处理叫做线性递归。
** 树形递归
   除了线性递归外，我们容易想到一种保存的数据和所需时间空间随n以指数增长的递归处理。最简单的例子就是菲波纳鍥数列的
   递归实现。
   #+begin_src scheme
     (define (fib n)
       (cond ((= n 0) 0)
             ((= n 1) 1)
             (else (+ (fib (- n 1))
                      (fib (- n 2))))))
   #+end_src
   每次进入两个（或多个）下一层，过程中保存的数据可以用树表示出来。显然，该过程也可以用迭代处理。不过在转化为迭代
   处理的过程中我们不能再只保存当前层的数据了，还需要保存之前层次计算得到的数据。类似的讨论可见[[https://iluvata.github.io/post/2021-02-24_greedy-and-dijkstra/][贪心算法]].
** 线性迭代
   至于线性迭代，通过名字直接理解就能知道，是耗费n的线性时间与空间复杂度的迭代处理。每次迭代中处理的步骤相同，
   总体迭代的次数和n线性相关。上面factorial的迭代实现就是一个很好的例子。
